# 이동교 202230124

## 3월 27일 (4주차)
#### README 파일 편집

### 자바의 특징(2)
#### 가비지 컬렉션 
* 자바 언어는 메모리 할당 기능은 있어도 메모리 반환 기능은 없음
* 사용하지 않는 메모리는 JVM에 의해 자동 반환 - 가비지 컬렉션

### 자바의 특징(3)
* 실시간 응용프로그럄애 부적합
* 타입 체크 엄격
* 자바는 바이트 코드를 인터프리터 방식으로 실행
* 기계어가 실행되는 것보다 느림

* 소스코드 : 사람이 읽을 수 있는 고수준 언어

* 바이트코드 : Java 컴파일러가 소스코드를 변환한 중간 코드, 바이트코드는JVM이 해석

* 기계어 : CPU가 직접 실행할 수 있는 0과 1의 이진코드

#### 바이트코드와 기계어 차이점 
* 바이트코드는 JVM이 실행하는 중간 코드 -> 운영체제와 CPU에 관계없이 사용
* 기계어는 CPU가 직접 실행하는 코드 -> 특정 하드웨어에 종속됨 

### 식별자 - 명명 규칙
* 식별자 : 클레스, 변수 상수, 메소드 등에 붙이는 이름

#### 식별자의 원칙
* '_','$'는 사용 가능
* 유니코드 문자 사용 가능, 한글 사용 X
* 키워드는 식별자로 사용불가
* 첫 번쨰 문자로 숫자는 사용불가
* '_',"$'를 시별자 첫 번쨰 문자로 일반적으로 잘 사용핮 않는다 
* 불린 리터럴과 널 리터럴은 식별자로 사용불가
* 길이제한 없음
* 대소문자 구별

### JAVA의 데이터 타입 
* 기본 자료형 : 8개
* 크기는 CPU나 운영체제에 따라 변하지 않음

#### 래퍼런스형의 용도는 3가지
* 클래스
* 인터페이스
* 배열

* 문자열은 String 클래스로 문자열 표현

### 참조 자료형 
* 주소를 저장할 수 없다
* JVM이 해당 주소로 안내
힙(Heap) 영역에 저장딘 객체의 메모리 주소
* 배열, 인터페이스, 혹은 열거형도 객체이기에 참조 자료형이다

### 참조 자료형을 사용 하는 이유
#### 메모리 안전성
* 잘못된 메모리 접근 문제가 발생 할 수 있다

#### 보안 강화 
* 버퍼 오버플로우 같은 보안 취약점 생길 가능성 높음
* 포인터를 활용한 해캉 기법은 JAVA에서 거의 불가능

### 메모의 구조 
* 힙(heap - FIFO)영역은 Java의 경우 JVM이 담당
* 스택 (stack - LIFO) 영역은 프로그램이 자동으로 사용하는 임시 메모리 영역 
* 힙이 스택을 침범 -> 힙 오버 플로우
* 스택이 힙을 침범 -> 스택 오버 플로우

### 변수의 선언 
* 번수 : 값을 임시로 저장 
* 변수 선언 : 데이터 타입에서 정한 크기의 메모리 할당

### 상수 선언ㄴ
* final 키워드 사용
* 상수 이름은 대문자

### var 키워드
* 타입을 생략하고 변수 선언
* 컴파일러가 추론하고 변수 타입 결정
* 변수 선언시 초기값 설정하지 않으면 컴파일 오류 발생

#### 좋게 사용하는 법
* 가독성이 명확 할 떄 사용 
* 상수를 적극 활용 


```java
public class Foo {
	public static void main(String[] args) {
		final double PI = 3.14;
		double radius = 10.2;
		double circleArea = radius*radius*PI;

		System.out.print("반지름" + radius + ", ");
		System.out.println("원의 면적 = " + circleArea);
	}
}
```

### 타입 변환
* 특정 데이터 타입의 값을 다른 데이터 타입의 값으로 변환
#### 자동 타입 변환
* 컴파일러에 의해 큰 타입으로 자동 변환

#### 강제 타입 변환 
* 개발자의 의도적 타입 변환

### 자바의 키 입력
#### System.in
* 자바의 표준 입력 스트림
* 바이트로 리턴하는 저수준 스트림

#### Scanner 클래스
* 바이트를 문자, 정수, 실수, 문자열, 불린 등 다양한 타입으로 변환하여 리턴, java.util.Scanner
* 객체를 생성해서 사용
* System.in에게 키를 읽게 하고, 원하는 타입으로 변환하여 리턴
* 입력되는 키 값을 공백으로 구분되는 토큰 단위로 읽움

### 연산자 
#### 산술 연산자 
* 더하기 (+), 빼기 (-), 곱하기(*), 나누기(/), 나머지(%)
#### 증감 연산자
* 증가 혹은 감소 시키는 연사 : ++, --
#### 대입 연산
* 연산의 오른쪽 결과는 왼쪽 변수에 대입
#### 비교 연산, 논리 연산
* 비교연산자 : 두개의 갑을 비교 true / false 결과
* 논리연산자 : 두 개의 논리 값에 논리 연산, 논리 결과
#### 조건 연산 
* 3 개의 피연산자로 구성된 삼항 연산자
```java 
public class prog_1 {
    public static void main(String[] args) {
        int a = 3, b = 5;

        System.out.println("두 수의 차는 " + ((a > b) ? ( a - b ) : (b - a)));
    }
}
```
#### 비트 연산 
* 비트 논리 연산 : 비트끼리 AND, OR, XOR, NOT 연산
* 비트 시프트 연산 : 비트를 오른쪽이나 왼쪽으로 이동

#### 비트 연산이 사용되는 경우 
1. 성능 최적화, 연산 속도 향상 : 곱셈,나눗셈 보다 비트 연산이 빠름
2. 퀀한 및 플래그 설정 : 여러 개의 상태를 하나의 int 변수에 저장할 떄
3. 데이터 압축 및 최적화 : 여러 개의 작은 값을 하나의 정수에 저장
4. 해싱 및 암호화 : 함수 및 암호화 알고리즘을 최적화
5. 빠른 연산 : 짝수/홀수 판별


## 3월 20일 (3주차)
#### README 파일 편집
* 절차지향언어 : 프로그램의 흐름을 순차적으로 처리
* 객체지향언어 : 데이터와 그 데이터를 다루는 함수(메서드)를 하나의 객체로 묶어서 사용

* 소스 : 프로그래밍 언어로 작성된 텍스트 파일
* 컴파일 : 소스 파일을 컴퓨터가 이해 할 수 있는 기계어로 만드는 과정
* 자바 : .JAVA -> .class
* C : .c -> .obj -> .exe

* 플랫폼 = 하드웨어 플랫폼 + 운영체제 플랫폼

* 바이트 코드 (.class)
* 자바 JVM에서 실행 가능한 바이너리 코드
* 자바 JVM이 인터프리터 방식으로 바이트 코드 해석

* JVM
* 플랫폼에 맞는 JVM울 제공,JVM저체는 플랫폼에 종속적
* 자바의 실행은 JM에서 클래스 파일(.class)을 바이트 코드 실행하는 것.

* javac , javadoc , jar , jmod , jilink , job , javap

API : JDK에 포함된 클래스 라이브러리

#### 자바의 특징 (1)
* 플랫폼 독립성 : 하드웨어 운영 체제에 종속 되지 않는 바이트 코드로 플랫폼 독집성
*
#### 자바의 특징 (2)
* 한 개의 class 파일 또는 다수의 class 파일로 구성
* 여러 폴더에 걸쳐 다수의 클래스 파일로 구성된 경우 : jar 압축 파일로 배포

* 패키지 : 서로 관련 있는 여러 클래스를 패키지로 묶어 관라(폴더 개념)

* 자바는 운영체제의 도움 없이 자체적으로 멀티스레드 지원



## 3월 13일 (2주차)
#### README 파일 편집

# h1 tag
## h2
### h3
#### h4
##### h5
###### h6

---

* 가가가
- 나나나

1. asda
2. asdasd
7. asdasd

```java
int firstNumber = 10;
int secondNumber = 5;
char operator = '+';
```
